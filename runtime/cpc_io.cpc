/*
Copyright (c) 2005-2007 by Juliusz Chroboczek.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include "compatibility.h"

#include "cpc_runtime.h"
#include "cpc_barrier.h"
#include "cpc_io.h"

#define _TIMEOUT_EXPIRED 1
#define _TIMEOUT_RESET 2


/*=========================   All Operating Systems   ========================*/
struct cpc_timeout {
    cpc_condvar *cancel, *expire;
    int flags;
    int secs;
    int usecs;
};

cps cpc_timeout *
cpc_timeout_get(int secs, int usecs)
{
    cpc_timeout *timeout;

    if(secs < 0 || usecs < 0)
        return NULL;
    timeout = malloc(sizeof(cpc_timeout));
    if(timeout == NULL)
        return NULL;

    timeout->flags = 0;

    timeout->cancel = cpc_condvar_get();
    if(timeout->cancel == NULL) {
        free(timeout);
        return NULL;
    }

    timeout->expire = cpc_condvar_get();
    if(timeout->expire == NULL) {
        cpc_condvar_release(timeout->cancel);
        free(timeout);
        return NULL;
    }

    cpc_timeout_restart(timeout, secs, usecs);
    return timeout;
}

cps void
cpc_timeout_restart(cpc_timeout *timeout, int secs, int usecs)
{
    if(timeout->secs >= 0)
        timeout->secs  = secs;
    if(timeout->usecs >= 0)
        timeout->usecs = usecs;
    if(timeout->flags == _TIMEOUT_EXPIRED) {
        cpc_spawn {
            int rc;
            while(1) {
                rc = cpc_sleep(timeout->secs, timeout->usecs, timeout->cancel);
                if(timeout->flags == _TIMEOUT_RESET) {
                    timeout->flags = 0;
                    continue;
                } else {
                    assert(timeout->flags == 0);
                    timeout->flags = _TIMEOUT_EXPIRED;
                    cpc_signal_all(timeout->expire);
                    break;
                }
            }
        }
        timeout->flags = 0;
        cpc_yield();                  /* Enter the sleep. */
    } else {
        timeout->flags = _TIMEOUT_RESET;
        cpc_signal(timeout->cancel);
    }
}

cpc_condvar *
cpc_timeout_condvar(cpc_timeout *timeout)
{
    return timeout->expire;
}

int
cpc_timeout_expired(cpc_timeout *timeout)
{
    return timeout->flags == _TIMEOUT_EXPIRED;
}

void
cpc_timeout_cancel(cpc_timeout *timeout)
{
    switch(timeout->flags) {
    case _TIMEOUT_EXPIRED : return;
    case _TIMEOUT_RESET   : timeout->flags = 0; /* no break */
    default               : cpc_signal(timeout->cancel);
    }
}

void
cpc_timeout_destroy(cpc_timeout *timeout)
{
    if(!timeout->flags)
        cpc_timeout_cancel(timeout);
    /* This is in a separate continuation, which is scheduled after the
       sleeping thread exits. */
    cpc_spawn {
        cpc_condvar_release(timeout->cancel);
        cpc_condvar_release(timeout->expire);
        free(timeout);
    }
}

/*=================================   Unix   =================================*/
#ifdef __unix__
int
cpc_setup_descriptor(int fd, int nonagle)
{
    int rc;
    int one = 1;
    rc = fcntl(fd, F_GETFL, 0);
    if(rc < 0) return -1;
    rc = fcntl(fd, F_SETFL, rc | O_NONBLOCK);
    if(rc < 0) return -1;
    if(nonagle) {
        rc = setsockopt(fd, SOL_TCP, TCP_NODELAY, (char*)&one, sizeof(one));
        if(rc < 0) return -1;
    }
    return 1;
}

cps int
cpc_write(int fd, void *buf, size_t count)
{
    int rc;
 again:
    rc = write(fd, buf, count);
    if(rc < 0 && (errno == EAGAIN || errno == EINTR)) {
        cpc_io_wait(fd, CPC_IO_OUT);
        goto again;
    }
    return rc;
}

cps int
cpc_write_timeout(int fd, void *buf, size_t count, int secs, int micros)
{
    cpc_condvar *c = cpc_condvar_get();
    cpc_barrier *barrier = cpc_barrier_get(3);
    int *done = malloc(sizeof(int));
    int *ret = malloc(sizeof(int));
    int rc;

    *done = 0;

    cpc_spawn {
        cpc_sleep(secs, micros, c);
        if(!*done) {
            *done = 2;
            cpc_signal(c);
        }
        cpc_barrier_await(barrier);
    }

    cpc_spawn {
    again:
        rc = write(fd, buf, count);
        if(rc < 0 && (errno == EAGAIN || errno == EINTR)) {
            cpc_io_wait(fd, CPC_IO_OUT, c);
            if(!*done)
                goto again;
        }
        if(!*done) {
            *done = 1;
            cpc_signal(c);
        }
        *ret = rc;
        cpc_barrier_await(barrier);
    }

    cpc_barrier_await(barrier);
    cpc_condvar_release(c);
    rc = *ret;
    free(ret);
    if(*done == 1) {
        free(done);
        return rc;
    } else {
        free(done);
        errno = EAGAIN;
        return -1;
    }
}

cps int
cpc_read(int fd, void *buf, size_t count)
{
    int rc;

 again:
    cpc_io_wait(fd, CPC_IO_IN);
    rc = read(fd, buf, count);
    if(rc < 0 && (errno == EAGAIN || errno == EINTR))
        goto again;

    return rc;
}

cps int
cpc_read_timeout(int fd, void *buf, size_t count, int secs, int micros)
{
    cpc_condvar *c = cpc_condvar_get();
    cpc_barrier *barrier = cpc_barrier_get(3);
    int *done = malloc(sizeof(int));
    int *ret = malloc(sizeof(int));
    int rc;

    *done = 0;

    cpc_spawn {
        cpc_sleep(secs, micros, c);
        if(!*done) {
            *done = 2;
            cpc_signal(c);
        }
        cpc_barrier_await(barrier);
    }

    cpc_spawn {
    again:
        cpc_io_wait(fd, CPC_IO_IN, c);
        rc = read(fd, buf, count);
        if(!*done && rc < 0 && (errno == EAGAIN || errno == EINTR))
            goto again;
        if(!*done) {
            *done = 1;
            cpc_signal(c);
        }
        *ret = rc;
        cpc_barrier_await(barrier);
    }

    cpc_barrier_await(barrier);
    cpc_condvar_release(c);

    rc = *ret;
    free(ret);

    if(*done == 1) {
        free(done);
        return rc;
    } else {
        free(done);
        errno = EAGAIN;
        return -1;
    }
}

/*================================   Windows   ===============================*/
#elif defined _WIN32
cpc_handle_t
cpc_open_file_std(const char *path, int openflags)
{
    cpc_handle_file_t handle = NULL;
    HANDLE file;
    DWORD access = 0;
    DWORD disposition = 0;
    int rc;

    switch(openflags & (O_RDWR | O_RDONLY | O_WRONLY)) {
    case O_RDONLY: access = GENERIC_READ;                 break;
    case O_WRONLY: access = GENERIC_WRITE;                break;
    case O_RDWR:   access = GENERIC_READ | GENERIC_WRITE; break;
    default: assert(0);
    }

    /* O_APPEND : rÃ©agit bizarrement sous unix en O_RDWR. */
    switch(openflags & (O_CREAT | O_TRUNC | O_EXCL)) {
    case 0:                 disposition = OPEN_EXISTING;    break;
    case O_CREAT:           disposition = OPEN_ALWAYS;      break;
    case O_CREAT | O_TRUNC: disposition = CREATE_ALWAYS;    break;
    case O_CREAT | O_EXCL:  disposition = CREATE_NEW;       break;
    case O_TRUNC:           disposition = TRUNCATE_EXISTING;break;
    default: assert(0);
    }

    file = CreateFile(path, access,
                      FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                      disposition,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    if(file == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    rc = cpc_setup_descriptor(file, 0);
    if(rc < 0) {
        CloseHandle(file);
        return NULL;
    }
    handle = malloc(sizeof(cpc_handle_file));
    handle->cpch_handle = file;
    handle->cpch_kind   = CPC_HANDLE_FILE;
    handle->cpch_offset = 0;
    return handle;
}

cpc_handle_t
cpc_open_socket_tcp(int family, int no_nagle)
{
    cpc_handle_t handle = NULL;
    SOCKET sock;
    int rc;
    sock = socket(family, SOCK_STREAM, IPPROTO_TCP);
    if (sock == INVALID_SOCKET)
        return NULL;
    rc = cpc_setup_descriptor(sock, no_nagle);
    if(rc < 0) return NULL;
    handle = malloc(sizeof(cpc_handle));
    handle->cpch_handle = sock;
    handle->cpch_kind   = CPC_HANDLE_SOCKET;
    return handle;
}

cpc_handle_t
cpc_open_socket_udp(int family)
{
    cpc_handle_t handle = NULL;
    SOCKET sock;
    int rc;
    sock = socket(family, SOCK_DGRAM, 0);
    if (sock == INVALID_SOCKET)
        return NULL;
    rc = cpc_setup_descriptor(sock, 0);
    if(rc < 0) return NULL;
    handle = malloc(sizeof(cpc_handle));
    handle->cpch_handle = sock;
    handle->cpch_kind   = CPC_HANDLE_SOCKET;
    return handle;
}

void
cpc_close_handle(cpc_handle_t handle)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        closesocket(handle->cpch_handle);
    else
        CloseHandle(handle->cpch_handle);
    free(handle);
}

int
cpc_setup_descriptor(HANDLE handle, int no_nagle)
{
    int rc;
    int one = 1;
    rc = cpc_io_associate_with_completion_port(handle);
    if (rc < 0) return -1;
    if(no_nagle) {
        rc = setsockopt(handle, SOL_TCP, TCP_NODELAY, (char*)&one, sizeof(one));
        if(rc < 0) return -2;
    }
    rc = SetFileCompletionNotificationModes(handle,
             FILE_SKIP_COMPLETION_PORT_ON_SUCCESS);
    if(!rc) return -3;
    return 1;
}

struct cpc_io_file {
    char *buffer;
    uint64_t offset;
    uint64_t count;
};
#define CPC_IO_BASIC_READ_OR_WRITE_BODY(function, offset, cond)         \
    {                                                                   \
        assert(handle->cpch_kind == CPC_HANDLE_FILE);                   \
        int64_t nbytes;                                                 \
        struct cpc_handle_file *fh = (void*)handle;                     \
        struct cpc_io_file closure = { buf, offset, count };    \
        cpc_async_prim f = &function;                                   \
        nbytes = cpc_call_async_prim(handle->cpch_handle, f, &closure, cond); \
        if(nbytes > 0) fh->cpch_offset = offset + nbytes;               \
        return nbytes;                                                  \
    }

static int64_t
cpc_write_aux(HANDLE handle, void *closure, OVERLAPPED *ovl,
                cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    struct cpc_io_file *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    ovl->Offset = data->offset & 0xFFFFFFFFLLU;
    ovl->OffsetHigh = (data->offset >> 32) & 0xFFFFFFFFLLU;
    rc = WriteFile(handle, data->buffer, data->count, nbytes, ovl);
    if(!rc) /* asynchronous read or error */
        return -(int64_t)GetLastError();
    return nbytes;
}

cps int64_t
cpc_write(cpc_handle_t handle, void *buf, size_t count)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_send(handle, buf, count);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_write_aux, fh->cpch_offset, NULL);
}

cps int64_t
cpc_write_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_send_cond(handle, buf, count, cond);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_write_aux, fh->cpch_offset, cond);
}

cps int64_t
cpc_write_at(cpc_handle_t handle, void *buf, size_t count, size_t offset)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_write_aux, offset, NULL);
}

cps int64_t
cpc_write_at_cond(cpc_handle_t handle, void *buf, size_t count,
                 size_t offset, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_write_aux, offset, cond);
}

static int64_t
cpc_read_aux(HANDLE handle, void *closure, OVERLAPPED *ovl,
                cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    struct cpc_io_file *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    ovl->Offset = data->offset & 0xFFFFFFFFLLU;
    ovl->OffsetHigh = (data->offset >> 32) & 0xFFFFFFFFLLU;
    rc = ReadFile(handle, data->buffer, data->count, nbytes, ovl);
    if(!rc) /* asynchronous read or error */
        return -(int64_t)GetLastError();
    return nbytes;
}

cps int64_t
cpc_read(cpc_handle_t handle, void *buf, size_t count)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_recv(handle, buf, count);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_read_aux, fh->cpch_offset, NULL);
}

cps int64_t
cpc_read_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_recv_cond(handle, buf, count, cond);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_read_aux, fh->cpch_offset, cond);
}

cps int64_t
cpc_read_at(cpc_handle_t handle, void *buf, size_t count, size_t offset)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_read_aux, offset, NULL);
}

cps int64_t
cpc_read_at_cond(cpc_handle_t handle, void *buf, size_t count,
                 size_t offset, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(cpc_read_aux, offset, cond);
}

struct cpc_io_tcp_basic {
    WSABUF wsaBuffer;
};
#define CPC_IO_SEND_OR_RECV_BODY(function,cond)                         \
    {                                                                   \
        int64_t nbytes;                                                 \
        cpc_async_prim f = &function;                                   \
        struct cpc_io_tcp_basic closure;                             \
        closure.wsaBuffer.buf = buf;                                    \
        closure.wsaBuffer.len = count;                                  \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        nbytes = cpc_call_async_prim(handle->cpch_handle, f, &closure, cond); \
        return nbytes;                                                  \
    }

static int64_t
cpc_send_aux(HANDLE handle, void *closure, OVERLAPPED *ovl, cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    DWORD flags = 0;
    SOCKET sock = (SOCKET)handle;
    struct cpc_io_tcp_basic *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = WSASend(sock, &data->wsaBuffer, 1, &nbytes, flags, ovl, NULL);
    if(rc == SOCKET_ERROR) /* asynchronous read or error */
        return -(int64_t)WSAGetLastError();
    return nbytes;
}

cps int64_t
cpc_send_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    CPC_IO_SEND_OR_RECV_BODY(cpc_send_aux, cond);
}

cps int64_t
cpc_send(cpc_handle_t handle, void *buf, size_t count)
{
    CPC_IO_SEND_OR_RECV_BODY(cpc_send_aux, NULL);
}

static int64_t
cpc_recv_aux(HANDLE handle, void *closure, OVERLAPPED *ovl,
             cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    DWORD flags = 0;
    SOCKET sock = (SOCKET)handle;
    struct cpc_io_tcp_basic *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = WSARecv(sock, &data->wsaBuffer, 1, &nbytes, &flags, ovl, NULL);
    if(rc == SOCKET_ERROR) /* asynchronous read or error */
        return -(int64_t)WSAGetLastError();
    return nbytes;
}

cps int64_t
cpc_recv_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    CPC_IO_SEND_OR_RECV_BODY(cpc_recv_aux, cond);
}

cps int64_t
cpc_recv(cpc_handle_t handle, void *buf, size_t count)
{
    CPC_IO_SEND_OR_RECV_BODY(cpc_recv_aux, NULL);
}

struct cpc_io_tcp_vector {
    WSABUF *wsaBuffer;
    int count;
};
#define CPC_IO_SENDV_OR_RECVV_BODY(function,cond)                       \
    {                                                                   \
        int64_t nbytes;                                                 \
        cpc_async_prim f = &function;                                   \
        struct cpc_io_tcp_vector closure;                            \
        closure.wsaBuffer = iobuf;                                      \
        closure.count = iocount;                                        \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        nbytes = cpc_call_async_prim(handle->cpch_handle, f, &closure, cond); \
        return nbytes;                                                  \
    }

static int64_t
cpc_sendv_aux(HANDLE handle, void *closure, OVERLAPPED *ovl, cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    DWORD flags = 0;
    SOCKET sock = (SOCKET)handle;
    struct cpc_io_tcp_vector *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = WSASend(sock, data->wsaBuffer, data->count, &nbytes, flags, ovl, NULL);
    if(rc == SOCKET_ERROR) /* asynchronous read or error */
        return -(int64_t)WSAGetLastError();
    return nbytes;
}

cps int64_t
cpc_sendv_cond(cpc_handle_t handle,
               cpc_iobuf *iobuf, int iocount, cpc_condvar *cond)
{
    CPC_IO_SENDV_OR_RECVV_BODY(cpc_sendv_aux, cond);
}

cps int64_t
cpc_sendv(cpc_handle_t handle, cpc_iobuf *iobuf, int iocount)
{
    CPC_IO_SENDV_OR_RECVV_BODY(cpc_sendv_aux, NULL);
}

struct cpc_io_from {
    WSABUF wsaBuffer;
    struct sockaddr *addr;
    int *addrlen;
};
struct cpc_io_to {
    WSABUF wsaBuffer;
    struct sockaddr *addr;
    int addrlen;
};
#define CPC_IO_RECVFROM_OR_SENDTO_BODY(closure_struct,function,cond)    \
    {                                                                   \
        int64_t nbytes;                                                 \
        cpc_async_prim f = &function;                                   \
        struct closure_struct closure;                                  \
        closure.wsaBuffer.buf = buf;                                    \
        closure.wsaBuffer.len = count;                                  \
        closure.addr = addr;                                            \
        closure.addrlen = addrlen;                                      \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        nbytes = cpc_call_async_prim(handle->cpch_handle, f, &closure, cond); \
        return nbytes;                                                  \
    }

static int64_t
cpc_recvfrom_aux(HANDLE handle, void *closure, OVERLAPPED *ovl,
                 cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    DWORD flags = 0;
    SOCKET sock = (SOCKET)handle;
    struct cpc_io_from *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = WSARecvFrom(sock, &data->wsaBuffer, 1, &nbytes, &flags,
                     data->addr, data->addrlen, ovl, NULL);
    if(rc == SOCKET_ERROR) /* asynchronous read or error */
        return -(int64_t)WSAGetLastError();
    return nbytes;
}

static int64_t
cpc_sendto_aux(HANDLE handle, void *closure, OVERLAPPED *ovl, cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    DWORD flags = 0;
    SOCKET sock = (SOCKET)handle;
    struct cpc_io_from *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = WSASendTo(sock, &data->wsaBuffer, 1, &nbytes, &flags,
                     data->addr, data->addrlen, ovl, NULL);
    if(rc == SOCKET_ERROR) /* asynchronous read or error */
        return -(int64_t)WSAGetLastError();
    return nbytes;
}

cps int64_t
cpc_recvfrom(cpc_handle_t handle, void *buf, size_t count,
             struct sockaddr *addr, int *addrlen)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(cpc_io_from, cpc_recvfrom_aux, NULL);
}
cps int64_t
cpc_recvfrom_cond(cpc_handle_t handle, void *buf, size_t count,
                  struct sockaddr *addr, int *addrlen, cpc_condvar *cond)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(cpc_io_from, cpc_recvfrom_aux, cond);
}

cps int64_t
cpc_sendto(cpc_handle_t handle, void *buf, size_t count,
           struct sockaddr *addr, int addrlen)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(cpc_io_to, cpc_sendto_aux, NULL);
}
cps int64_t
cpc_sendto_cond(cpc_handle_t handle, void *buf, size_t count,
                struct sockaddr *addr, int addrlen, cpc_condvar *cond)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(cpc_io_to, cpc_sendto_aux, cond);
}


#define PROTOCOL_SIZE         (sizeof(struct sockaddr))
#define LOCAL_ADDRESS_LENGTH  (PROTOCOL_SIZE + 16)
#define REMOTE_ADDRESS_LENGTH (PROTOCOL_SIZE + 16)
struct cpc_accept_aux_struct {
    SOCKET acceptedSocket;
    char *buffer;
    uint64_t count;
};
static int64_t
cpc_accept_aux(HANDLE handle, void *closure, OVERLAPPED *ovl,
                cpc_condvar *cond)
{
    int rc;
    DWORD nbytes;
    SOCKET serverSocket = (void*) handle;
    struct cpc_accept_aux_struct *data = closure;
    memset(ovl, 0, sizeof(OVERLAPPED));
    rc = AcceptEx(serverSocket,
                  data->acceptedSocket,
                  data->buffer,
                  data->count - LOCAL_ADDRESS_LENGTH - REMOTE_ADDRESS_LENGTH,
                  LOCAL_ADDRESS_LENGTH,
                  REMOTE_ADDRESS_LENGTH,
                  &nbytes,
                  ovl);
    if(!rc) /* asynchronous read or error */
        return -(int64_t)GetLastError();
    return nbytes;
}

cps int64_t
cpc_accept(cpc_handle_t serverHandle, cpc_handle_t acceptedHandle,
           void *buf, size_t count)
{
    int64_t nbytes;
    int64_t rc;
    SOCKET serv_sock = serverHandle->cpch_handle;
    SOCKET acc_sock = acceptedHandle->cpch_handle;
    struct cpc_accept_aux_struct closure;
    cpc_async_prim f = &cpc_accept_aux;
    int is_big_enough = count >= LOCAL_ADDRESS_LENGTH + REMOTE_ADDRESS_LENGTH;

    assert(serverHandle->cpch_kind == CPC_HANDLE_SOCKET);

    closure.acceptedSocket = acc_sock;
    if(is_big_enough) {
        closure.buffer = buf;
        closure.count = count;
    } else {
        int buf_size = count + LOCAL_ADDRESS_LENGTH + REMOTE_ADDRESS_LENGTH;
        closure.buffer = malloc(buf_size);
        if(closure.buffer == NULL) return -WSA_NOT_ENOUGH_MEMORY;
        closure.count = buf_size;
    }

    nbytes = cpc_call_async_prim(serv_sock, f, &closure, NULL);
    if(!is_big_enough) {
        if(buf != NULL)
            memcpy(buf, closure.buffer, count);
        free(closure.buffer);
    }
    if(nbytes < 0)
        return nbytes;

    rc =  setsockopt(acc_sock, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                     (char *)&serv_sock, sizeof(serv_sock));
    if (rc < 0) {
        WSA_print_error("setsockopt (UPTADE ACCEPT CONTEXT)");
        exit(1);
    }

    return nbytes;
}

#endif
