/*
Copyright (c) 2005-2007 by Juliusz Chroboczek.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include "compatibility.h"

#include "cpc_runtime.h"
#include "cpc_barrier.h"
#include "cpc_io.h"

#define _TIMEOUT_EXPIRED 1
#define _TIMEOUT_RESET 2


/*=========================   All Operating Systems   ========================*/
struct cpc_timeout {
    cpc_condvar *cancel, *expire;
    int flags;
    int secs;
    int usecs;
};

cps cpc_timeout *
cpc_timeout_get(int secs, int usecs)
{
    cpc_timeout *timeout;

    if(secs < 0 || usecs < 0)
        return NULL;
    timeout = malloc(sizeof(cpc_timeout));
    if(timeout == NULL)
        return NULL;

    timeout->flags = 0;

    timeout->cancel = cpc_condvar_get();
    if(timeout->cancel == NULL) {
        free(timeout);
        return NULL;
    }

    timeout->expire = cpc_condvar_get();
    if(timeout->expire == NULL) {
        cpc_condvar_release(timeout->cancel);
        free(timeout);
        return NULL;
    }

    cpc_timeout_restart(timeout, secs, usecs);
    return timeout;
}

cps void
cpc_timeout_restart(cpc_timeout *timeout, int secs, int usecs)
{
    if(timeout->secs >= 0)
        timeout->secs  = secs;
    if(timeout->usecs >= 0)
        timeout->usecs = usecs;
    if(timeout->flags == _TIMEOUT_EXPIRED) {
        cpc_spawn {
            int rc;
            while(1) {
                rc = cpc_sleep(timeout->secs, timeout->usecs, timeout->cancel);
                if(timeout->flags == _TIMEOUT_RESET) {
                    timeout->flags = 0;
                    continue;
                } else {
                    assert(timeout->flags == 0);
                    timeout->flags = _TIMEOUT_EXPIRED;
                    cpc_signal_all(timeout->expire);
                    break;
                }
            }
        }
        timeout->flags = 0;
        cpc_yield();                  /* Enter the sleep. */
    } else {
        timeout->flags = _TIMEOUT_RESET;
        cpc_signal(timeout->cancel);
    }
}

cpc_condvar *
cpc_timeout_condvar(cpc_timeout *timeout)
{
    return timeout->expire;
}

int
cpc_timeout_expired(cpc_timeout *timeout)
{
    return timeout->flags == _TIMEOUT_EXPIRED;
}

void
cpc_timeout_cancel(cpc_timeout *timeout)
{
    switch(timeout->flags) {
    case _TIMEOUT_EXPIRED : return;
    case _TIMEOUT_RESET   : timeout->flags = 0; /* no break */
    default               : cpc_signal(timeout->cancel);
    }
}

void
cpc_timeout_destroy(cpc_timeout *timeout)
{
    if(!timeout->flags)
        cpc_timeout_cancel(timeout);
    /* This is in a separate continuation, which is scheduled after the
       sleeping thread exits. */
    cpc_spawn {
        cpc_condvar_release(timeout->cancel);
        cpc_condvar_release(timeout->expire);
        free(timeout);
    }
}

/*=================================   Unix   =================================*/
#ifdef __unix__
int
cpc_setup_descriptor(int fd, int nonagle)
{
    int rc;
    int one = 1;
    rc = fcntl(fd, F_GETFL, 0);
    if(rc < 0) return -1;
    rc = fcntl(fd, F_SETFL, rc | O_NONBLOCK);
    if(rc < 0) return -1;
    if(nonagle) {
        rc = setsockopt(fd, SOL_TCP, TCP_NODELAY, (char*)&one, sizeof(one));
        if(rc < 0) return -1;
    }
    return 1;
}

cps int
cpc_write(int fd, void *buf, size_t count)
{
    int rc;
 again:
    rc = write(fd, buf, count);
    if(rc < 0 && (errno == EAGAIN || errno == EINTR)) {
        cpc_io_wait(fd, CPC_IO_OUT);
        goto again;
    }
    return rc;
}

cps int
cpc_write_timeout(int fd, void *buf, size_t count, int secs, int micros)
{
    cpc_condvar *c = cpc_condvar_get();
    cpc_barrier *barrier = cpc_barrier_get(3);
    int *done = malloc(sizeof(int));
    int *ret = malloc(sizeof(int));
    int rc;

    *done = 0;

    cpc_spawn {
        cpc_sleep(secs, micros, c);
        if(!*done) {
            *done = 2;
            cpc_signal(c);
        }
        cpc_barrier_await(barrier);
    }

    cpc_spawn {
    again:
        rc = write(fd, buf, count);
        if(rc < 0 && (errno == EAGAIN || errno == EINTR)) {
            cpc_io_wait(fd, CPC_IO_OUT, c);
            if(!*done)
                goto again;
        }
        if(!*done) {
            *done = 1;
            cpc_signal(c);
        }
        *ret = rc;
        cpc_barrier_await(barrier);
    }

    cpc_barrier_await(barrier);
    cpc_condvar_release(c);
    rc = *ret;
    free(ret);
    if(*done == 1) {
        free(done);
        return rc;
    } else {
        free(done);
        errno = EAGAIN;
        return -1;
    }
}

cps int
cpc_read(int fd, void *buf, size_t count)
{
    int rc;

 again:
    cpc_io_wait(fd, CPC_IO_IN);
    rc = read(fd, buf, count);
    if(rc < 0 && (errno == EAGAIN || errno == EINTR))
        goto again;

    return rc;
}

cps int
cpc_read_timeout(int fd, void *buf, size_t count, int secs, int micros)
{
    cpc_condvar *c = cpc_condvar_get();
    cpc_barrier *barrier = cpc_barrier_get(3);
    int *done = malloc(sizeof(int));
    int *ret = malloc(sizeof(int));
    int rc;

    *done = 0;

    cpc_spawn {
        cpc_sleep(secs, micros, c);
        if(!*done) {
            *done = 2;
            cpc_signal(c);
        }
        cpc_barrier_await(barrier);
    }

    cpc_spawn {
    again:
        cpc_io_wait(fd, CPC_IO_IN, c);
        rc = read(fd, buf, count);
        if(!*done && rc < 0 && (errno == EAGAIN || errno == EINTR))
            goto again;
        if(!*done) {
            *done = 1;
            cpc_signal(c);
        }
        *ret = rc;
        cpc_barrier_await(barrier);
    }

    cpc_barrier_await(barrier);
    cpc_condvar_release(c);

    rc = *ret;
    free(ret);

    if(*done == 1) {
        free(done);
        return rc;
    } else {
        free(done);
        errno = EAGAIN;
        return -1;
    }
}

/*================================   Windows   ===============================*/
#elif defined _WIN32
/* About safety of WSABUF-based functions (from msnd).

   "If this function is completed in an overlapped manner, it is the Winsock
   service provider's responsibility to capture the WSABUF structures before
   returning from this call. This enables applications to build stack-based
   WSABUF arrays pointed to by the lpBuffers parameter. */
#pragma cpc_no_retain("ReadFile", "WriteFile")
#pragma cpc_no_retain("WSARecv", "WSASend", "WSARecvFrom", "WSASendTo", "AcceptEx")


cpc_handle_t
cpc_open_file_std(const char *path, int openflags)
{
    cpc_handle_file_t handle = NULL;
    HANDLE file;
    DWORD access = 0;
    DWORD disposition = 0;
    int rc;

    switch(openflags & (O_RDWR | O_RDONLY | O_WRONLY)) {
    case O_RDONLY: access = GENERIC_READ;                 break;
    case O_WRONLY: access = GENERIC_WRITE;                break;
    case O_RDWR:   access = GENERIC_READ | GENERIC_WRITE; break;
    default: assert(0);
    }

    /* O_APPEND : rÃ©agit bizarrement sous unix en O_RDWR. */
    switch(openflags & (O_CREAT | O_TRUNC | O_EXCL)) {
    case 0:                 disposition = OPEN_EXISTING;    break;
    case O_CREAT:           disposition = OPEN_ALWAYS;      break;
    case O_CREAT | O_TRUNC: disposition = CREATE_ALWAYS;    break;
    case O_CREAT | O_EXCL:  disposition = CREATE_NEW;       break;
    case O_TRUNC:           disposition = TRUNCATE_EXISTING;break;
    default: assert(0);
    }

    file = CreateFile(path, access,
                      FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                      disposition,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    if(file == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    rc = cpc_setup_descriptor(file, 0);
    if(rc < 0) {
        CloseHandle(file);
        return NULL;
    }
    handle = malloc(sizeof(cpc_handle_file));
    handle->cpch_handle = file;
    handle->cpch_kind   = CPC_HANDLE_FILE;
    handle->cpch_offset = 0;
    return handle;
}

cpc_handle_t
cpc_open_socket_tcp(int family, int no_nagle)
{
    cpc_handle_t handle = NULL;
    SOCKET sock;
    int rc;
    sock = socket(family, SOCK_STREAM, IPPROTO_TCP);
    if (sock == INVALID_SOCKET)
        return NULL;
    rc = cpc_setup_descriptor(sock, no_nagle);
    if(rc < 0) return NULL;
    handle = malloc(sizeof(cpc_handle));
    handle->cpch_handle = sock;
    handle->cpch_kind   = CPC_HANDLE_SOCKET;
    return handle;
}

cpc_handle_t
cpc_open_socket_udp(int family)
{
    cpc_handle_t handle = NULL;
    SOCKET sock;
    int rc;
    sock = socket(family, SOCK_DGRAM, 0);
    if (sock == INVALID_SOCKET)
        return NULL;
    rc = cpc_setup_descriptor(sock, 0);
    if(rc < 0) return NULL;
    handle = malloc(sizeof(cpc_handle));
    handle->cpch_handle = sock;
    handle->cpch_kind   = CPC_HANDLE_SOCKET;
    return handle;
}

void
cpc_close_handle(cpc_handle_t handle)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        closesocket(handle->cpch_handle);
    else
        CloseHandle(handle->cpch_handle);
    free(handle);
}

int
cpc_setup_descriptor(HANDLE handle, int no_nagle)
{
    int rc;
    int one = 1;
    rc = cpc_io_associate_with_completion_port(handle);
    if (rc < 0) return -1;
    if(no_nagle) {
        rc = setsockopt(handle, SOL_TCP, TCP_NODELAY, (char*)&one, sizeof(one));
        if(rc < 0) return -2;
    }
    rc = SetFileCompletionNotificationModes(handle,
             FILE_SKIP_COMPLETION_PORT_ON_SUCCESS);
    if(!rc) return -3;
    return 1;
}

/* XXX This macro is not used. */
#define CPC_AIO_WAIT_HANDLING(async_cond, error_function,               \
                              pending_cond, handle, cond)               \
    {                                                                   \
        if(async_cond) { /* asynchronous operation or error */          \
            rc = error_function();                                      \
            if(pending_cond)                                            \
                rc64 = -(int64_t)rc;                                    \
            else                                                        \
                rc64 = cpc_aio_wait(handle, ovl, cond);                 \
        } else {                                                        \
            rc64 = nbytes;                                              \
        }                                                               \
    }                                                                   \

#define CPC_IO_BASIC_READ_OR_WRITE_BODY(SysCall, offset, cond)          \
    {                                                                   \
        assert(handle->cpch_kind == CPC_HANDLE_FILE);                   \
        struct cpc_handle_file *fh = (void*)handle;                     \
        DWORD offsetLow = offset & 0xFFFFFFFFLLU ;                      \
        DWORD offsetHigh = (offset >> 32) & 0xFFFFFFFFLLU ;             \
        cpc_overlapped *ovl = cpc_get_overlapped(offsetLow, offsetHigh); \
        int rc;                                                         \
        int64_t rc64;                                                   \
        DWORD nbytes;                                                   \
        rc = SysCall(handle->cpch_handle, buf, count,                   \
                     &nbytes, (POVERLAPPED)ovl);                        \
        if(!rc) { /* asynchronous operation or error */                 \
            rc = GetLastError();                                        \
            if(rc != ERROR_IO_PENDING)                                  \
                rc64 = -(int64_t)rc;                                    \
            else                                                        \
                rc64 = cpc_aio_wait(handle->cpch_handle, ovl, cond);    \
        } else {                                                        \
            rc64 = nbytes;                                              \
        }                                                               \
        cpc_free_overlapped(ovl);                                       \
        if(rc64 >= 0)                                                   \
            fh->cpch_offset = offset + rc64;                            \
        return rc64;                                                    \
    }                                                                   \

cps int64_t
cpc_write(cpc_handle_t handle, void *buf, size_t count)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_send(handle, buf, count);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(WriteFile, fh->cpch_offset, NULL);
}

cps int64_t
cpc_write_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_send_cond(handle, buf, count, cond);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(WriteFile, fh->cpch_offset, cond);
}

cps int64_t
cpc_write_at(cpc_handle_t handle, void *buf, size_t count, size_t offset)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    int64_t offset64 = offset;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(WriteFile, offset64, NULL);
}

cps int64_t
cpc_write_at_cond(cpc_handle_t handle, void *buf, size_t count,
                 size_t offset, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    int64_t offset64 = offset;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(WriteFile, offset64, cond);
}

cps int64_t
cpc_read(cpc_handle_t handle, void *buf, size_t count)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_recv(handle, buf, count);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(ReadFile, fh->cpch_offset, NULL);
}

cps int64_t
cpc_read_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return cpc_recv_cond(handle, buf, count, cond);
    CPC_IO_BASIC_READ_OR_WRITE_BODY(ReadFile, fh->cpch_offset, cond);
}

cps int64_t
cpc_read_at(cpc_handle_t handle, void *buf, size_t count, size_t offset)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    int64_t offset64 = offset;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(ReadFile, offset64, NULL);
}

cps int64_t
cpc_read_at_cond(cpc_handle_t handle, void *buf, size_t count,
                 size_t offset, cpc_condvar *cond)
{
    if(handle->cpch_kind == CPC_HANDLE_SOCKET)
        return -(int64_t)ERROR_INVALID_HANDLE;
    int64_t offset64 = offset;
    CPC_IO_BASIC_READ_OR_WRITE_BODY(ReadFile, offset64, cond);
}

#define CPC_IO_SEND_OR_RECV_BODY(SysCall, flags, cond)                  \
    {                                                                   \
        cpc_overlapped *ovl = cpc_get_overlapped(0,0);                  \
        int rc;                                                         \
        int64_t rc64;                                                   \
        DWORD nbytes;                                                   \
        WSABUF wsaBuffer;                                               \
        wsaBuffer.buf = buf;                                            \
        wsaBuffer.len = count;                                          \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        rc = SysCall((SOCKET)handle->cpch_handle, &wsaBuffer, 1,        \
                     &nbytes, flags, (POVERLAPPED)ovl, NULL);           \
        if(rc == SOCKET_ERROR) { /* asynchronous operation or error */  \
            rc = WSAGetLastError();                                     \
            if(rc != WSA_IO_PENDING)                                    \
                rc64 = -(int64_t)rc;                                    \
            else                                                        \
                rc64 = cpc_aio_wait(handle->cpch_handle, ovl, cond);    \
        } else {                                                        \
            rc64 = nbytes;                                              \
        }                                                               \
        cpc_free_overlapped(ovl);                                       \
        return rc64;                                                    \
    }                                                                   \

cps int64_t
cpc_send_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    CPC_IO_SEND_OR_RECV_BODY(WSASend, 0, cond);
}

cps int64_t
cpc_send(cpc_handle_t handle, void *buf, size_t count)
{
    CPC_IO_SEND_OR_RECV_BODY(WSASend, 0, NULL);
}

cps int64_t
cpc_recv_cond(cpc_handle_t handle, void *buf, size_t count, cpc_condvar *cond)
{
    DWORD flags = 0;
    CPC_IO_SEND_OR_RECV_BODY(WSARecv, &flags, cond);
}

cps int64_t
cpc_recv(cpc_handle_t handle, void *buf, size_t count)
{
    DWORD flags = 0;
    CPC_IO_SEND_OR_RECV_BODY(WSARecv, &flags, NULL);
}

#define CPC_IO_SENDV_OR_RECVV_BODY(SysCall, flags, cond)                \
    {                                                                   \
        cpc_overlapped *ovl = cpc_get_overlapped(0,0);                  \
        int rc;                                                         \
        int64_t rc64;                                                   \
        DWORD nbytes;                                                   \
        WSABUF *wsaBuffer = iobuf;                                      \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        rc = SysCall((SOCKET)handle->cpch_handle, wsaBuffer, iocount,   \
                     &nbytes, flags, (POVERLAPPED)ovl, NULL);           \
        if(rc == SOCKET_ERROR) { /* asynchronous operation or error */  \
            rc = WSAGetLastError();                                     \
            if(rc != WSA_IO_PENDING)                                    \
                rc64 = -(int64_t)rc;                                    \
            else                                                        \
                rc64 = cpc_aio_wait(handle->cpch_handle, ovl, cond);    \
        } else {                                                        \
            rc64 = nbytes;                                              \
        }                                                               \
        cpc_free_overlapped(ovl);                                       \
        return rc64;                                                    \
    }                                                                   \

cps int64_t
cpc_sendv(cpc_handle_t handle, cpc_iobuf *iobuf, int iocount)
{
    CPC_IO_SENDV_OR_RECVV_BODY(WSASend, 0, NULL);
}

cps int64_t
cpc_sendv_cond(cpc_handle_t handle,
               cpc_iobuf *iobuf, int iocount, cpc_condvar *cond)
{
    CPC_IO_SENDV_OR_RECVV_BODY(WSASend, 0, cond);
}

cps int64_t
cpc_recvv(cpc_handle_t handle, cpc_iobuf *iobuf, int iocount)
{
    DWORD flags = 0;
    CPC_IO_SENDV_OR_RECVV_BODY(WSARecv, &flags, NULL);
}

cps int64_t
cpc_recvv_cond(cpc_handle_t handle,
               cpc_iobuf *iobuf, int iocount, cpc_condvar *cond)
{
    DWORD flags = 0;
    CPC_IO_SENDV_OR_RECVV_BODY(WSARecv, &flags, cond);
}

#define CPC_IO_RECVFROM_OR_SENDTO_BODY(SysCall, flags, cond)            \
    {                                                                   \
        cpc_overlapped *ovl = cpc_get_overlapped(0,0);                  \
        int rc;                                                         \
        int64_t rc64;                                                   \
        DWORD nbytes;                                                   \
        WSABUF wsaBuffer;                                               \
        wsaBuffer.buf = buf;                                            \
        wsaBuffer.len = count;                                          \
        assert(handle->cpch_kind == CPC_HANDLE_SOCKET);                 \
        rc = SysCall((SOCKET)handle->cpch_handle, &wsaBuffer, 1,        \
                     &nbytes, flags, (POVERLAPPED)ovl, addr, addrlen, NULL); \
        if(rc == SOCKET_ERROR) { /* asynchronous operation or error */  \
            rc = WSAGetLastError();                                     \
            if(rc != WSA_IO_PENDING)                                    \
                rc64 = -(int64_t)rc;                                    \
            else                                                        \
                rc64 = cpc_aio_wait(handle->cpch_handle, ovl, cond);    \
        } else {                                                        \
            rc64 = nbytes;                                              \
        }                                                               \
        cpc_free_overlapped(ovl);                                       \
        return rc64;                                                    \
    }                                                                   \

cps int64_t
cpc_sendto(cpc_handle_t handle, void *buf, size_t count,
           struct sockaddr *addr, int addrlen)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(WSASendTo, 0, NULL);
}

cps int64_t
cpc_sendto_cond(cpc_handle_t handle, void *buf, size_t count,
                struct sockaddr *addr, int addrlen, cpc_condvar *cond)
{
    CPC_IO_RECVFROM_OR_SENDTO_BODY(WSASendTo, 0, cond);
}

cps int64_t
cpc_recvfrom(cpc_handle_t handle, void *buf, size_t count,
             struct sockaddr *addr, int *addrlen)
{
    DWORD flags = 0;
    CPC_IO_RECVFROM_OR_SENDTO_BODY(WSARecvFrom, &flags, NULL);
}

cps int64_t
cpc_recvfrom_cond(cpc_handle_t handle, void *buf, size_t count,
                  struct sockaddr *addr, int *addrlen, cpc_condvar *cond)
{
    DWORD flags = 0;
    CPC_IO_RECVFROM_OR_SENDTO_BODY(WSARecvFrom, &flags, cond);
}


#define PROTOCOL_SIZE         (sizeof(struct sockaddr_in6))
#define LOCAL_ADDRESS_LENGTH  (PROTOCOL_SIZE + 16)
#define REMOTE_ADDRESS_LENGTH (PROTOCOL_SIZE + 16)
cps int64_t
cpc_accept(cpc_handle_t serverHandle, cpc_handle_t acceptedHandle,
           void *buf, size_t count)
{
    DWORD nbytes;
    int rc;
    int64_t rc64;
    SOCKET serverSocket = serverHandle->cpch_handle;
    SOCKET acceptedSocket = acceptedHandle->cpch_handle;
    int is_big_enough = count >= LOCAL_ADDRESS_LENGTH + REMOTE_ADDRESS_LENGTH;
    char *accept_buffer;
    uint64_t accept_count;
    cpc_overlapped *ovl = cpc_get_overlapped(0,0);

    assert(serverHandle->cpch_kind == CPC_HANDLE_SOCKET);

    if(is_big_enough) {
        accept_buffer = buf;
        accept_count = count;
    } else {
        int buf_size = count + LOCAL_ADDRESS_LENGTH + REMOTE_ADDRESS_LENGTH;
        accept_buffer = malloc(buf_size);
        if(accept_buffer == NULL) return -WSA_NOT_ENOUGH_MEMORY;
        accept_count = buf_size;
    }

    rc = AcceptEx(serverSocket,
                  acceptedSocket,
                  accept_buffer,
                  accept_count - LOCAL_ADDRESS_LENGTH - REMOTE_ADDRESS_LENGTH,
                  LOCAL_ADDRESS_LENGTH,
                  REMOTE_ADDRESS_LENGTH,
                  &nbytes,
                  (POVERLAPPED)ovl);
    if(!rc) { /* asynchronous operation or error */
        rc = WSAGetLastError();
        /* msdn says AcceptEx returns ERROR_IO_PENDING with WSAGetLastError.
           This is strange (because ERROR_IO_PENDING != WSA_IO_PENDING). */
        if(rc != ERROR_IO_PENDING && rc != WSA_IO_PENDING)
            rc64 = -(int64_t)rc;
        else
            rc64 = cpc_aio_wait(serverHandle->cpch_handle, ovl, NULL);
    } else {
        rc64 = nbytes;
    }
    cpc_free_overlapped(ovl);

    if(!is_big_enough) {
        if(buf != NULL)
            memcpy(buf, accept_buffer, count);
        free(accept_buffer);
    }
    if(rc64 < 0)
        return rc64;

    rc =  setsockopt(acceptedSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                     (char *)&serverSocket, sizeof(serverSocket));
    if (rc < 0) {
        WSA_print_error("cpc_accept().setsockopt (UPTADE ACCEPT CONTEXT)");
        exit(1);
    }

    return rc64;
}

#endif
