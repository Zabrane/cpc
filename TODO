[src/ext/cpc.ml]
* Invalid_argument(List.map2)
  => make a good error message! (pb: number of parameters)
* during CPS conversion, if there is a typo in a cpc_spawn, building
  fails with a Not_found error message
  => print a more informative error message (or check it before)
* OPT: There is an inefficiency with return values:
  x = f(); return x; is converted to
  x = f(); w(x); return; with w(x){return x;}
  This is by design in CPC but I think we can't avoid it anyway since
  CIL (sometimes) produces the following in the first place:
  tmp = f(); x = tmp;
  (Yes, even when there is NO cast implied.)
  In that case, w becomes: w(tmp){x = tmp; return x;}
  Both cases could probably be optimized just before cps conversion,
  basically by removing w (this would save a function call, and a patch,
  f patching directly the next continuation, instead of going through 
  w).
* OPT: Return probably does not have to be split if there is no
  assignment before it
  => is it worth the trouble?
* cpc_yield en mode détaché : se réattacher au threadpool s'il est
  saturé, ne rien faire sinon.
* optimiser les boucles : 
  f(i,j,k) { i++; g(k,i,j);} => g(k, i++, j);
  => pas d'exemple dans Hekate
* variable locale volatile : qu'est-ce que ça veut dire ? faut-il boxer ?
  idem pour const, restrict, etc. En général, on fait quoi des attributs ?
* aligner sur 8 bits plutôt que 16 (mais que faire des fonctions qui
  contiennent des long double ?) ou intégrer le pointeur de fonction
  à la fin de la struct (dans new_arglist, qu'on renommerait en push).
