/* EXPECTED OUTPUT
1
2
3
4
5
* END OF OUTPUT */

#include <stdio.h>
#include "cpc/cpc_lib.h"

cps void print(int i) { printf("%d\n", i); }

cps void double_free_bug(int y) {

    cpc_barrier *b = cpc_barrier_get(2);

    int x = y;
    int *p = &x;

    /* If freeing is done in inner functions, this should lead a double
     * free bug, or a segfault (depending on the scheduling). */
    cpc_spawn { x++; cpc_barrier_await(b); }

    cpc_barrier_await(b);
    print(x); // x must not have been incremented, because of the copy semantics


    /* Just to be sure x is boxed, make it cross a cooperation point */
    int *q = p;
    return;
}
    
cps void set_x(int *p, int y) { *p = y; }

cps void foo(int y){
    int x = 0;
    set_x(&x, y);
    print(x);
}

void
tricky_copy(int y) {
    int x = y;
    int *p = &x;
    cpc_spawn { print(x); *p = *p + 1; print(x); }
}

cps void
box_formal(int x) {
  int *p = &x;
  cpc_yield();
  print(*p);
}

cps void
test() {
    foo(1);
    box_formal(2);
    double_free_bug(3);
    tricky_copy(4);
}

int main(){
    cpc_spawn test();
    cpc_main_loop();
    return 0;
}
