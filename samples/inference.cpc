#define cps __attribute__((__cps__))
#define nocps __attribute__((__nocps__))

/* Roots */
cps extern void f();
nocps extern void g();
void h() { };

/* spurious cps */
cps void f1() { }

/* cps ok */
cps void f2() { f(); }

/* missing cps */
void f3() { f(); }

/* missing cps but ok because f1 is spurious */
void f4() { f1(); }

/* spurious cps, but in fact ok because f3 is missing */
cps void f5() { f3(); }

/* Deeper, just to check it works */
cps void f6() { f5(); }
void f7() { f4(); }

/* nocps ok */
nocps void g1() { g(); }

/* conflicting annotation */
nocps cps void g2() { }

/* nocps inferred as cps */
nocps void g3() { f(); }

/* nocps called from native: ok */
void g4() { g(); }

/* nocps called from cps: bad */
cps void f8() { f(); g(); g1(); }

/* nocps called from spurious cps: suspicious */
cps void f9() { g(); }

/* nocps called from missing cps: suspicious */
void f10() { f(); g(); }

/* cps function pointer */
typedef cps void cpsfun(void);
typedef void nativefun(void);
cpsfun *p = f;

/* missing cps here */
void f11() { p(); }

/* not spurious, because a pointer is taken so we should trust the annotation, just like extern functions */
cps void f12() { h(); }
cpsfun *p2 = f12;

/* Checking wrong (implicit) casts */
struct s {
  void cps f(void);
  void cps g(void);
  void h(void);
};

void cps a(void);
void b(void);

struct s foo = {
  .f = a,   /* OK */
  .g = b,   /* Bad */
  .h = a,   /* Bad  */
};

cpsfun *p3 = a; /* OK */
nativefun *p4 = a; /* Bad */

cpsfun *f13() {
  return &a;
}

void f14() {
  nativefun *p = a; /* Bad */
  cpsfun *p2 = b;     /* Bad */

  p = f13(); /* Bad */
  p2 = f13(); /* OK */
}
