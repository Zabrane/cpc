#include <cpc/cpc_runtime.h>
#include <cpc/compatibility.h>

#ifndef SOL_TCP
# define SOL_TCP IPPROTO_TCP
#endif

#define PORT 4200
#define BUFFER_SIZE 4096

#include "cpc/cpc_lib.h"

cps void launch_server(int serverPort);
cps void accept_connection(cpc_handle_t serverSocket);
cps void handle_connection(cpc_handle_t sock, char *buf, DWORD nbytes);

static struct sockaddr_in addr;
static unsigned int len;

char *root = "../../benchmarks/web/";

#ifdef STATIC
static char resp[] = "HTTP/1.0 200 OK\r\n"
                    "Content-type: text/html\r\n"
                    "Server: Trivial-cpc\r\n"
                    "Connection: close\r\n\r\n"
  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n"
  " \"http://www.w3.org/TR/html4/loose.dtd\">\n"
  "<html><head>\n"
  "<title>Welcome to Polipo</title>\n"
  "</head><body>\n"
  "<h1>Welcome to Polipo</h1>\n\n"
  "<p><a href=\"doc/\">The Polipo manual</a>.\n\n"
  "<p><a href=\"polipo/\">The configuration interface</a>.\n"
  "</body></html>\n";
static int resp_size = sizeof(resp);
#else
#endif

#undef htons

int
main(int argc, char **argv)
{
    int serverPort = PORT;

    if (argc >= 2)
        sscanf(argv[1], "%d", &serverPort);

    /* Here, we must use a thread cpc, because some cpc needs to init the
       completion port. */
    cpc_spawn launch_server(serverPort);

    cpc_main_loop();

    return 0;
}

cps void
launch_server(int serverPort)
{
    cpc_handle_t serverSocket;
    int rc;
    WSADATA wsaData;
    WORD versionRequested = MAKEWORD(2,2);
    int one = 1;

    rc = WSAStartup(versionRequested, &wsaData); /* init wsaData */
    if(rc != 0) {
        printf("WSAStartup: %d", rc);
        exit(1);
    }

    serverSocket = cpc_open_socket_tcp(AF_INET, 1);
    if(serverSocket == NULL) { print_error("serverSocket"); exit(1); }

    rc = setsockopt(serverSocket->cpch_handle, SOL_SOCKET, SO_REUSEADDR,
                    (char *)&one, sizeof(one));
    if(rc < 0) perror("setsockopt(SO_REUSEADDR)");

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(serverPort);
    rc = bind(serverSocket->cpch_handle, (struct sockaddr*)&addr, sizeof(addr));
    if(rc == SOCKET_ERROR) { WSA_print_error("bind"); exit(1); }

    rc = listen(serverSocket->cpch_handle, 1024);
    if(rc == SOCKET_ERROR) { WSA_print_error("listen"); exit(1); }

    printf("server started on port %d\n", serverPort);

    for(rc = 0; rc < 2000; rc++)
        cpc_spawn accept_connection(serverSocket);
}

cps void
accept_connection(cpc_handle_t serverSocket)
{
    int64_t rc;
    cpc_handle_t acceptedSocket;
    char *buf;
    buf = malloc(BUFFER_SIZE);
    if(buf == NULL) {
        print_error("malloc");
        return;
    }
    while(1) {
    again:
        acceptedSocket = cpc_open_socket_tcp(AF_INET, 1);
        if(acceptedSocket == NULL) {
            print_error("cpc_open_socket_tcp");
            cpc_yield();
            goto again;
        }
    again2:
        rc = cpc_accept(serverSocket, acceptedSocket, buf, BUFFER_SIZE);
        if(rc < 0) {
            print_errno("accept", -(long)rc);
            cpc_yield();
            goto again2;
        }

        handle_connection(acceptedSocket, buf, rc);
    }
}

cps void
handle_connection(cpc_handle_t sock, char *buf, DWORD nbytes)
{
    int64_t rc = 0;
    int readed;
    int n, len;
    cpc_handle_t file;
    char *fn = NULL;
    int i, val;

    val = 1;

    if(nbytes == 0) /* Gracefull closure */
        goto fail;
    readed = nbytes;

 again:
    if(readed < 4)
        goto fail;

    if(memcmp(buf, "GET ", 4) != 0)
        goto fail;

    for(i = 5; i < readed; i++)
        if(buf[i] == ' ' || buf[i] == '\r' || buf[i] == '\n')
            break;
    if(i == readed && readed < BUFFER_SIZE) {
        rc = cpc_read(sock, buf + readed, BUFFER_SIZE - readed);
        if(rc < 0) {
            print_errno("read", -(long)rc);
            goto fail;
        }
        if(rc == 0) /* graceful close */
            goto fail;
        readed += rc;
        goto again;
    }

    len = strlen(root);
    
    fn = malloc(len + 1 + i - 5 + 12);
    strcpy(fn, root);
    memcpy(fn + len, buf + 5, i - 5);
    
    if(buf[i - 1] == '/')
        strcpy(fn + len + i - 5, "index.html");
    else
        fn[len + i - 5] = '\0';

    i--;

 search:
    while(i < readed - 3)
      if(buf[i++] == '\r' && buf[i] == '\n'){
        i++; if(buf[i++] == '\r' && buf[i] == '\n')
          goto send;
        }

    if(readed < BUFFER_SIZE) {
        rc = cpc_read(sock, buf + rc, BUFFER_SIZE - rc);
        if(rc < 0) {
            print_errno("read", -(long)rc);
            goto fail_fn;
        }
        if(rc == 0) /* graceful close */
            goto fail_fn;
        readed += rc;
        goto search;
    }
 
 send:
#ifdef STATIC
    rc = cpc_write(sock, &resp, resp_size);
    if(rc != resp_size) { perror("write"); goto fail; }
#else
    file = cpc_open_file_std(fn, O_RDONLY);
    if(file == NULL) {
        int err;
        char *message;
        if(errno == ENOENT) {
            err = 404;
            message = "File doesn't exist";
        } else if(errno == EACCES || errno == EPERM) {
            err = 403;
            message = "Forbidden";
        } else if(errno == EMFILE || errno == ENFILE) {
            err = 500;
            message = "Out of file descriptors";
        } else if(errno == ENOMEM) {
            err = 500;
            message = "Out of memory";
        } else {
            err = 500;
            message = "Unknown error";
        }
        n = snprintf(buf, BUFFER_SIZE,
                     "HTTP/1.1 %d %s\r\n"
                     "Content-Type: text/html\r\n"
                     "Server: Trivial-cpc\r\n"
                     "Connection: close\r\n"
                     "\r\n"
                     "<html><body><p>Couldn't open %s: %s</body></html>\r\n",
                     err, message, fn, message);
        free(fn);
        fn = NULL;
    } else {
        free(fn);
        fn = NULL;
        n = snprintf(buf, BUFFER_SIZE,
                     "HTTP/1.1 200 OK\r\n"
                     "Content-Type: text/html\r\n"
                     "Server: Trivial-cpc\r\n"
                     "Connection: close\r\n"
                     "\r\n");
        rc = cpc_read(file, buf + n, BUFFER_SIZE - n);
        if(rc >= 0)
            n += rc;
    }

    rc = cpc_write(sock, buf, n);
    if(rc < 0) {
        print_errno("write", -rc);
        goto fail_file;
    }

    if(file != NULL) {
        while(1) {
            rc = cpc_read(file, buf, BUFFER_SIZE);
            if(rc <= 0) break;
            rc = cpc_write(sock, buf, rc);
            if(rc <= 0) break;
            cpc_yield();
        }
        cpc_close_handle(file);
        file = NULL;
    }

#endif

 fail_file:
    if(file != NULL)
        cpc_close_handle(file);
 fail_fn:
    if(fn != NULL)
      free(fn);
 fail:
    cpc_close_handle(sock);
    free(buf);
    return;
}
