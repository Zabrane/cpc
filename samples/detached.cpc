#include <stdio.h>
#include <assert.h>

cps void
g(char c)
{
    int i;

    cps void f(void) { printf("%c: %d\n", c, i); }

    for(i = 0; i < 10; i++) {
        cpc_detached {
            forbidden_label:
            f();
            // continue;
            cpc_spawn { printf("%c has been there\n", c); }
            if(i==9)
              goto end;
            // cps void forbidden_function(void) { return; }
            if(i % 2 == 0)
                cpc_attached f();
            if(i == 8 && c == 'b')
                return;
            // forbidden break
            // break;
        }
        f();
    }
    end: printf("This is the end of %c.\n", c);
}

cps void
clock ()
{
    int i;

    for(i=0; i < 10; i++) {
        printf("Tic!\n");
        cpc_sleep(0,500);
    }
}

cps void
test_gotos ()
{
    
    cpc_spawn clock ();
    cpc_yield();

    cpc_detached {
        printf("test_gotos: detached.\n");
        goto attlab;
        detlab:
        printf("test_gotos: detlab.\n");
        sleep(1);
    }

    printf("Back in normal (attached) mode.\n");
    cpc_set_sched(cpc_default_pool);

    cpc_attached {
        printf("test_gotos: attached and quit.\n");
        return;
        attlab:
        printf("test_gotos: attlab.\n");
        sleep(1);
        goto detlab;
    }
}

int
main()
{
    cpc_sched *pool = cpc_threadpool_get(5);
    cpc_spawn { g('a'); printf("A a fini, B devrait bientot.\n"); }
    cpc_spawn
    {
        g('b');
        cpc_detach(pool);
        /* Yes, I can do this since cpc_threadpool_release doesn't block
         * and waits for every thread to be attached before destroying
         * the pool! */
        cpc_threadpool_release(pool);
        sleep(2);
        printf("B meurt détaché.\n");
    }
    cpc_spawn
    {
        printf("D1.\n");
        cpc_detach; cpc_detach;
        printf("D2.\n");
        cpc_sleep(1,500);
        cpc_attach; cpc_attach;
        assert(cpc_default_sched == cpc_set_sched(cpc_default_sched));
        printf("D3.\n");
    }
    cpc_spawn test_gotos();
    cpc_main_loop();
    return 0;
}

